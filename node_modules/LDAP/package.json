{
  "author": {
    "name": "Jeremy Childs",
    "email": "jeremyc@ssimicro.com"
  },
  "name": "LDAP",
  "description": "LDAP Binding for node.js",
  "version": "1.2.0",
  "homepage": "https://github.com/jeremycx/node-LDAP",
  "repository": {
    "type": "git",
    "url": "git://github.com/jeremycx/node-LDAP.git"
  },
  "main": "./LDAP.js",
  "engines": {
    "node": ">= 0.8.0"
  },
  "devDependencies": {},
  "scripts": {
    "install": "node-gyp rebuild"
  },
  "gypfile": true,
  "readme": "node-LDAP 1.2.0\n===============\n\nOpenLDAP client bindings for Node.js. Requires libraries from\nhttp://www.openldap.org installed.\n\nThis latest version implements proper reconnects to a lost LDAP server.\n\nOf note in this release is access to LDAP Syncrepl. With this API, you\ncan subscribe to changes to the LDAP database, and be notified (and\nfire a callback) when anything is changed in LDAP. Use Syncrepl to\ncompletely mirror an LDAP database, or use it to implement triggers\nthat perform an action when LDAP is modified.\n\nThe API is finally stable, and (somewhat) sane.\n\n\nContributing\n------------\n\nAny and all patches and pull requests are certainly welcome.\n\nThanks to:\n----------\n* Petr BÄ›han\n* YANG Xudong\n* Victor Powell\n\nDependencies\n------------\n\nNode >= 0.8\n\nInstall\n=======\n\nYou must ensure you have the latest OpenLDAP client libraries\ninstalled from http://www.openldap.org\n\nTo install the latest release from npm:\n\n    npm install LDAP\n\nIf this fails, please ensure you have uuid.h available (on Ubuntu,\ninstall the uuid-dev package).\n\n\nAPI\n===\n\n    new LDAP(otions);\n\nCreating an instance:\n\n```js\nvar LDAP = require('LDAP');\nvar ldap = new LDAP({\n    uri: 'ldap://my.ldap.server',\n    version: 3,\n    starttls: false,\n    connecttimeout: 1,\n    reconnect: true\n});\n```\n\nldap.open()\n-----------\n\n    ldap.open(function(err));\n\nNow that you have an instance, you can open a connection. This will\nautomatically reconnect until you close():\n\n```js\nldap.open(function(err) {\n    if (err) {\n       throw new Error('Can not connect');\n    }\n    // connection is ready.\n\n});\n```\n\nYou can disable the automatic reconnect by setting the `reconnect`\noption to false.\n\nldap.simplebind()\n-----------------\nCalling open automatically does an anonymous bind to check to make\nsure the connection is actually open. If you call simplebind(), you\nwill upgrade the existing anonymous bind.\n\n    ldap.simplebind(bind_options, function(err));\n\nOptions are binddn and password:\n\n```js\nbind_options = {\n    binddn: '',\n    password: ''\n}\n```\n\nldap.search()\n-------------\n    ldap.search(search_options, function(err, data));\n\nOptions are provided as a JS object:\n\n```js\nsearch_options = {\n    base: '',\n    scope: '',\n    filter: '',\n    attrs: ''\n}\n```\n\nScopes are specified as one of the following integers:\n\n* Connection.BASE = 0;\n* Connection.ONELEVEL = 1;\n* Connection.SUBTREE = 2;\n* Connection.SUBORDINATE = 3;\n* Connection.DEFAULT = -1;\n\nResults are returned as an array of zero or more objects. Each object\nhas attributes named after the LDAP attributes in the found\nrecord(s). Each attribute contains an array of values for that\nattribute (even if the attribute is single-valued - having to check typeof()\nbefore you can act on /anything/ is a pet peeve of\nmine). The exception to this rule is the 'dn' attribute - this is\nalways a single-valued string.\n\n```js\n[ { gidNumber: [ '2000' ],\n  objectClass: [ 'posixAccount', 'top', 'account' ],\n  uidNumber: [ '3214' ],\n  uid: [ 'fred' ],\n  homeDirectory: [ '/home/fred' ],\n  cn: [ 'fred' ],\n  dn: 'cn=fred,dc=ssimicro,dc=com' } ]\n```\n\nLDAP servers are usually limited in how many items they are willing to return -\n1024 or 4096 are some typical values. For larger LDAP directories, you need to\neither partition your results with filter, or use paged search. To get\na paged search, add the following attributes to your search request:\n\n```js\nsearch_options = {\n    base: '',\n    scope: '',\n    filter: '',\n    attrs: '',\n    pagesize: n\n}\n```\n\nThe callback will be called with a new parameter: cookie. Pass this\ncookie back in subsequent searches to get the next page of results:\n\n```js\nsearch_options = {\n    base: '',\n    scope: '',\n    filter: '',\n    attrs: '',\n    pagesize: n,\n    cookie: cookie\n}\n```\n\nAs of version 1.2.0 you can also read the rootDSE entry of an ldap server.\nTo do so, simply issue a read request with base set to an empty string:\n\n```js\nsearch_options = {\n  base: '',\n  scope: Connection.BASE,  // 0\n  // ... other options as necessary\n}\n```\n\nldap.findandbind()\n------------------\nA convenience function that is in here only to encourage developers to\ndo LDAP authentication \"the right way\" if possible.\n\n    ldap.findandbind(fb_options, function(err, data))\n\nOptions are exactly like the search options, with the addition of a\n\"password\" attribute:\n\n```js\nfb_options = {\n    base: '',\n    filter: '',\n    scope: '',\n    attrs: '',\n    password: ''\n}\n```\n\nCalls the callback with the record it authenticated against.\n\nNote: since findandbind leaves the connection in an authenticated\nstate, you probably don't want to do a findandbind with a general\npurpose instance of this library, as you would be sending one user's\nqueries on the authenticated connection of the last user to log\nin. Depending on your configuration, this may not even be an issue,\nbut you should be aware.\n\nDid someone say that asyncronous programming wasn't perilous?\n\nThere are three obvious solutions to this problem:\n\n* Use two instances of this library (and thus two TCP connections) -\n  one for authenication binds, and the other for general purpose use\n  (which may be pre-bound as admin or some other suitably priveleged\n  user). You are then completely in charge of authorization (can this\n  user edit that user?).\n\n* Create a new instance for each authenticated user, and reconnect\n  that user to their own instance with each page load. The advantage of\n  this strategy is you can then rely on LDAP's authorization systems\n  (slapd then decides what each user can and can't do).\n\n* Create, bind, and close a connection for each user's initial visit, and\n  use cookies and session trickery for subsequent visits.\n\nldap.add()\n----------\n\n    ldap.add(dn, [attrs], function(err))\n\ndn is the full DN of the record you want to add, attrs to be provided\nas follows:\n\n```js\nvar attrs = [\n    { attr: 'objectClass',  vals: [ 'organizationalPerson', 'person', 'top' ] },\n    { attr: 'sn',           vals: [ 'Smith' ] },\n    { attr: 'badattr',      vals: [ 'Fried' ] }\n]\n```\n\nldap.modify()\n-------------\n\n    ldap.modify(dn, [ changes ], function(err))\n\nModifies the provided dn as per the changes array provided. Ops are\none of \"add\", \"delete\" or \"replace\".\n\n```js\nvar changes = [\n    { op: 'add',\n      attr: 'title',\n      vals: [ 'King of Callbacks' ]\n    }\n]\n```\n\nldap.rename()\n-------------\n\n    ldap.rename(dn, newrdn, function(err))\n\nWill rename the entry to the new RDN provided.\n\nExample:\n\n```js\nldap.rename('cn=name,dc=example,dc=com', 'cn=newname')\n```\n\nldap.remove()\n-------------\n\n    ldap.remove(dn, function(err))\n\nDeletes an entry.\n\nExample:\n\n```js\nldap.remove('cn=name,dc=example,dc=com', function(err) {\n  if (err) {\n    // Could not delete entry\n  }\n});\n```\n\nSchema\n======\n\nTo instantiate:\n\n```js\nvar LDAP = require('LDAP');\nvar schema = new LDAP.Schema({\n    init_attr: function(attr),\n    init_obj: function(obj),\n    ready: function()\n})\n```\n\ninit_attr is called as each attribute is added so you can\naugment the attributes as they are loaded (add friendly labels, for\ninstance). Similarly, init_obj is called as each objectClass is loaded\nso you can add your own properties to objectClasses.\n\nready is called when the schema has been completely loaded from the server.\n\nOnce the schema are loaded, you can get an objectClass like this:\n\n    schema.getObjectClass('person')\n\nGet a specific attribute:\n\n    schema.getAttribute('cn');\n\nGiven a LDAP search, result, get all the possible attributes associated with it:\n\n    schema.getAttributesForRec(searchres);\n\n\nSYNCREPL API\n============\n\nIf you are connecting to an LDAP server with syncrepl overlay enabled,\nyou can be notified of updates to the LDAP tree. Begin by connecting,\nthen issue the ldap.sync() command:\n\n    ldap.sync(options)\n\nThe options are as follows:\n\n```js\n{\n    base: '',\n    scope: ldap.SUBTREE,\n    filter: '(objectClass=*)',\n    attrs: '* +',\n    rid: '000',\n    cookie: '',\n    syncentry: function(data),\n    syncintermediate: function(data),\n    syncresult: function(data)\n}\n```\n\nThe cookie attribute is used to send a cookie to the server to ensure\nsync continues where you last left off.\n\nThe rid attribute is required, and should be set to a unique value for\nthe server you are syncing to.\n\nThe function callbacks are called upon initial refresh, and as new\ndata is available.\n\nsyncentry(data)\n--------------------------------\nWhen this callback fires, you should call ldap.getcookie() to record the\ncurrent cookie and save it somewhere. You can provide this cookie to the\nldap.sync() call when your process restarts.\n\n\nsyncintermediate()\n-----------------\nTBD.\n\nsyncresult(data)\n---------------\nTBD.\n\ngetcookie()\n----------\nThis function returns the current cookie from the sync session. You can\nprovide this cookie on the next run to pick up where you left off syncing.\n\n\nTODO:\n-----\n* Integration testing for syncrepl.\n* Real-world testing of syncrepl.\n* Testing against Microsoft Active Directory is welcome as I don't\nhave a server to test against.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jeremycx/node-LDAP/issues"
  },
  "_id": "LDAP@1.2.0",
  "_from": "ldap@"
}
